# [迷宫](<https://www.luogu.com.cn/problem/P1605>)

~~本蒟蒻做了一下之后，提交代码发现，自己只有70分，果然是听却wa声一片之后，发现直接没有判断他开始的点之后也算一个障碍点（因为后面每次都会自动的移动一格）~~

## 题目背景

给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

## 题目描述

无

## 输入格式

第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。

## 输出格式

给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。

## 输入输出样例

#### 输入 #1

```
2 2 1
1 1 2 2
1 2
```

#### 输出 #1

```
1
```

## 说明/提示

【数据规模】

1≤N,M≤5

下面就是dfs的基本操作了：废话不多说直接上代码哈



```java


import java.util.Arrays;
import java.util.Scanner;

public class Main {
    static int [][] arr;
    static boolean [][] vis;
    static int n,m,t;
    static int[] dx={0,0,1,-1};
    static int[] dy = {1,-1,0,0};
    static int endx;
    static int endy;
    //判断当前的位置是否是障碍点经过的地方
    static int []x;
    static int []y;
    static int res;
    public static boolean check(int sx,int sy){
//        for(int i =0;i<t;i++){
            if(arr[sx][sy]==1){
                return false;
            }
//        }
        return true;
    }
    public static void dfs(int x,int y){
        if(x==endx&&y==endy){
            res++;
            return;
        }

        for(int i =0;i<4;i++){
            int tempx = x + dx[i];
            int tempy = y + dy[i];
            if(tempx<=0||tempy<=0||tempx>n||tempy>m){
              continue;
            }
            if(!vis[tempx][tempy] && check(tempx,tempy)){
                vis[tempx][tempy] = true;
                dfs(tempx,tempy);
                vis[tempx][tempy] = false;
            }
        }

    }
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        n = cin.nextInt();
        m = cin.nextInt();
        t  =cin.nextInt();
        arr = new int[n+1][m+1];
        vis = new boolean[n+1][m+1];
        x = new int[t];
        y = new int[t];

        int startx = cin.nextInt();
        int starty = cin.nextInt();

        endx = cin.nextInt();
        endy = cin.nextInt();
        for(int i =0;i<t;i++){
            x[i] = cin.nextInt();
            y[i] = cin.nextInt();
            arr[x[i]][y[i]] = 1;
        }
        res = 0;
        arr[startx][starty]=1;
        dfs(startx,starty);
//        System.out.println(Arrays.toString(x));
//        System.out.println(Arrays.toString(y));
        System.out.println(res);
        cin.close();
    }
}

```

